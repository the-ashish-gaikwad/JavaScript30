**How do people write "logically clean / well-structured" code like that?**

Here are the most important mental habits & patterns that separate "it somehow works" code from code that looks like it was written by someone who thinks clearly.

### Core principles (the mindset shift)

| Order | Principle                          | What people who write clean code actually do                                                                 | One-liner version people repeat to themselves                     |
|------|------------------------------------|---------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------|
| 1    | One level of abstraction at a time | Every function should answer **one question** at one level of detail                                       | "Does this function do one thing?"                                |
| 2    | Name things brutally honestly      | If the name is vague → the understanding is vague → force yourself to rename until it's obvious             | "If I had to explain this variable/function to a 12-year-old…"    |
| 3    | Early returns (guard clauses)      | Handle all sad/unhappy/invalid cases at the **beginning** of the function → main happy path stays flat      | "Get the ugly cases out of the way first"                         |
| 4    | Extract until you can't extract anymore (then maybe stop) | If you see the same 4–7 lines repeating or a block that's >8–10 lines → almost always extract                | "Can I give this block a good name?"                              |
| 5    | Single source of truth             | The same decision/logic should appear **only once** in the codebase                                         | "Where is the single place that knows X?"                         |
| 6    | Make invalid states unrepresentable| Use data structures / types / attributes so that impossible situations literally can't be created           | "How can I make it impossible to write a bug here?"               |
| 7    | Read code like English             | Good code should be readable roughly top-to-bottom without too many jumps                                  | "Can I understand what happens by just reading once?"             |

### Practical patterns you saw in the drumkit refactor

Pattern                               | What it solves                              | Typical before (messy)                               | Typical after (clean)
--------------------------------------|---------------------------------------------|------------------------------------------------------|-----------------------------------------------
Decision → lookup table / data-driven | Removes if-else chains                      | 9× `if (key === "KeyA") … else if …`                 | `audio[data-key="${keyCode}"]`
Unified handler function             | Eliminates code duplication                 | separate click logic + keydown logic                 | one `handleDrum(e)` function
Early return (guard clause)          | Removes deep nesting                        | `if (audio) { if (btn) { play… } }`                  | `if (!audio || !button) return; …happy path…`
Event → unified data extraction      | Same code path for mouse & keyboard         | `if click → classList[0] else e.code`                | `key = e.type === 'keydown' ? e.code : target.dataset.key`
Meaningful small helper functions    | Hides repetitive ceremony                   | inline `classList.add/remove` + setTimeout 3×        | `flash(element)`

### Quick checklist you can paste next to your editor (very practical)

Before you commit / show someone your code, ask:

1. Does every function have **one clear responsibility**?
2. Are invalid cases handled **early** (at the top)?
3. Did I **extract repeated code** into named functions?
4. Can I **delete half the comments** because names are clear?
5. Is the **happy path** (main logic) flat / easy to read?
6. Did I use the same logic/data in **only one place**?
7. Are variable/function names **brutally descriptive**?

### Realistic learning order (what usually works fastest)

Month 1–3  
• early returns / guard clauses  
• extract small helper functions  
• stop using magic numbers/strings → variables or constants

Month 3–8  
• remove almost all if-else chains → object / Map / dataset lookups  
• write one handler for similar events  
• name things longer & more precisely

Month 8+  
• start thinking "how can I make wrong code look obviously wrong"  
• try to reduce state / mutable variables  
• play with data-structure choices that prevent bugs

Which of these feels furthest away from your current style right now?

(If you tell me I can show you 2–3 concrete examples of transforming messy → clean in your own drumkit code — or in any other small piece you want to improve.)